eventChangesDependedAmqpListener.enabled=true
eventChangesDependedAmqpListener.exchangeName=eventChangedFanout
eventChangesDependedAmqpListener.queueName=eventChangedQueue

# kafka stateoffchange is enabled
kafka.event.stateoffchange.enabled=true
kafka.event.stateoffchange.transfer.expire-time=7
kafka.event.stateoffchange.transfer.expire-chrono-unit=DAYS

kafka.event.stateoffchange.transfer.batch=500

kafka.event.stateoffchange.bootstrap-servers=kafka.local.own:9092
kafka.event.stateoffchange.security.protocol=PLAINTEXT
# The following parameters are only filled in case the ${kafka.security.protocol} takes a value SSL or SASL_SSL
# kafka.stateoffchange.security.ssl.key,password = Password of the private key in the key store file.
# kafka.stateoffchange.security.ssl.keystore.location = Location of the key store file.
# kafka.stateoffchange.security.ssl.keystore.password = Store password for the key store file.
# kafka.stateoffchange.security.ssl.truststore.location = Location of the trust store file.
# kafka.stateoffchange.security.ssl.truststore.password = Store password for the trust store file.

kafka.event.stateoffchange.producer.acks=all
# kafka.stateoffchange.producer.retries = Setting a value greater than zero will cause the client to resend any record whose send fails with a potentially transient error
# kafka.stateoffchange.producer.batch-size = Default batch size in bytes
# kafka.stateoffchange.producer.buffer-memory = The total bytes of memory the producer can use to buffer records waiting to be sent to the server
# kafka.stateoffchange.producer.compression-type = The compression type for all data generated by the producer. (none, gzip, snappy or lz4)

kafka.event.stateoffchange.producer.topic=event-state-kafka

